---
title: "Lecture 4: `dplyr`"
author: ""
format:  
  revealjs:
    theme: resources/presentation_theme.scss
    transition: slide
    slideNumber: true
    highlightStyle: github
    highlightLanguage: r
    backgroundTransition: fade
    code: true
embed-resources: true
title-slide-attributes:
    data-background-size: contain
    data-background-opacity: "number"
bibliography: resources/bib-final.bib
editor_options: 
  chunk_output_type: console
---

## `dplyr` (and friends)

::: {.incremental}

- `dplyr` makes it easy to perform data manipulation...
- A collection of verbs (do this) helps us translate thought to code
   - `mutate` (create) new variables
   - `select` variables
   - `filter` observations
   - `summarise` values
   - `arrange` observations or rows
- `dplyr` functions are pipeable, the data argument has the first position, and each function returns a data frame 

:::

## Data in our examples


```{r}
#| eval: true
#| echo: true
#| message: false
#| warning: false

library(exscidata) # Load the data package
library(tidyverse) # tidyverse includes dplyr

glimpse(cyclingstudy) # Overview of variables in the data set



```


## `select()` - Select variables (columns) in a data set

:::: {.columns}


::: {.column width="48%"}
```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
        select(subject, 
               group, 
               timepoint, 
               cmj.max) %>%
        print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
        select(subject, group, timepoint, cmj.max) %>%
        print()

```

:::

::::

## `select()` - Select a range of columns with `:`

:::: {.columns}


::: {.column width="48%"}
```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
        select(subject:age, 
               cmj.max) %>%
        print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
        select(subject:age, 
               cmj.max) %>%
        print()

```

:::

::::


## `select()` - Select and rename columns

:::: {.columns}


::: {.column width="48%"}
```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(participant = subject, 
        group, 
        timepoint,
        cmj.max) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
        select(participant = subject, 
               group, 
               timepoint,
               cmj.max) %>%
        print()

```

:::

::::


## `select()` and selection helpers

- `last_col()`/`everything()`
- `starts_with()`
- `ends_with()`
- `contains()`
- `all_off()`/`any_off()`
- `where()`



## Select by position with `last_col()` or name with `everything()`

:::: {.columns}


::: {.column width="48%"}


- `last_col()` selects the last column in a data set. Adding an offset selects the last column - `n`.
- `everything()` selects all columns in a data set. 



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(last_col()) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(last_col()) %>%
 print()

```

:::

::::

## Select by position with `last_col()` or name with `everything()`

:::: {.columns}


::: {.column width="48%"}


- `everything()` selects all columns in a data set. 
- Can also be used with a list of variables (e.g. `everything(vars = c("subject", "age"))`



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(everything()) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(everything()) %>%
 print()

```

:::

::::



## Select columns based on variable names

:::: {.columns}


::: {.column width="48%"}


- `starts_with()`, `ends_with()` and `contains()` helps us select columns with repeating patterns.



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(starts_with("lac.")) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(starts_with("lac.")) %>%
 print()

```

:::

::::

## Select columns based on variable names

:::: {.columns}


::: {.column width="48%"}


- `starts_with()`, `ends_with()` and `contains()` helps us select columns with repeating patterns.



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(ends_with("max")) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(ends_with("max")) %>%
 print()

```

:::

::::


## Select columns based on variable names

:::: {.columns}


::: {.column width="48%"}


- `starts_with()`, `ends_with()` and `contains()` helps us select columns with repeating patterns.



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(contains("VE")) %>%
 print()


```

:::

::: {.column width="52%"}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(contains("VE")) %>%
 print()

```

:::

::::


## Select columns based on variable names

:::: {.columns}


::: {.column width="48%"}


- `all_of()` and `any_of()` solves a problem in selecting variables...



```{r}
#| eval: false
#| echo: true



my_columns <- c("subject", "age", "cmj.max")

# This will not work
cyclingstudy %>%
 select(my_columns) %>%
 print()

# This works!
cyclingstudy %>%
 select(all_of(my_columns)) %>%
 print()



```

:::

::: {.column width="52%"}




```{r}
#| eval: true
#| echo: false

my_columns <- c("subject", "age", "cmj.max")
# This works!
cyclingstudy %>%
 select(all_of(my_columns)) %>%
 print()

```

:::

::::


## Select columns based on variable names

:::: {.columns}


::: {.column width="48%"}

- `any_of()` does not give an error when a variable in the vector does not exist. 



```{r}
#| eval: false
#| echo: true



my_columns <- c("subject", 
                "age", 
                "cmj.max", 
                "another_column")


cyclingstudy %>%
 select(any_of(my_columns)) %>%
 print()



```

:::

::: {.column width="52%"}




```{r}
#| eval: true
#| echo: false

my_columns <- c("subject", 
                "age", 
                "cmj.max", 
                "another_column")
cyclingstudy %>%
 select(any_of(my_columns)) %>%
 print()

```

:::

::::

## Select columns based on variable type





```{r}
#| eval: false
#| echo: true



# Select numeric vectors
cyclingstudy %>%
 select(where(is.numeric)) %>%
 print()

```




::: {.fragment}

```{r}
#| eval: true
#| echo: false


# Select numeric vectors
cyclingstudy %>%
 select(where(is.numeric)) %>%
 print()

```


:::




## `mutate()` - Add or overwrite variables




```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(subject, 
        weight.T1, 
        VO2.max) %>%
 mutate(VO2.max_kg = VO2.max / weight.T1) %>%
 print()

```



::: {.fragment}

```{r}
#| eval: true
#| echo: false



cyclingstudy %>%
 select(subject, 
        weight.T1, 
        VO2.max) %>%
 mutate(VO2.max_kg = VO2.max / weight.T1) %>%
 print()

```


:::




## `mutate()` - Add or overwrite variables using group-wise operations

- `mutate()` can be used to do group-wise operations using `.by = var`
- 



::: {.r-stack}

::: {.fragment}

:::: {.columns}


::: {.column width="48%"}



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(subject, 
        timepoint,
        height.T1) %>%
 filter(timepoint == "meso2") %>%
 print()

```

:::

::: {.column width="52%"}


::: {.fragment}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(subject, 
        timepoint,
        height.T1) %>%
 filter(timepoint == "meso2") %>%
 print()

```


:::

:::

::::

:::

::: {.fragment}

:::: {.columns}


::: {.column width="48%"}



```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 select(subject, 
        timepoint,
        height.T1) %>%
 mutate(height.T1 = mean(height.T1, 
                         na.rm = TRUE), 
        .by = subject) %>%
 filter(timepoint == "meso2") %>%
 print()

```

:::

::: {.column width="52%"}


::: {.fragment}

```{r}
#| eval: true
#| echo: false


cyclingstudy %>%
 select(subject, 
        timepoint,
        height.T1) %>%
 mutate(height.T1 = mean(height.T1, na.rm = TRUE), 
        .by = subject) %>%
        filter(timepoint == "meso2") %>%
 print()

```


:::

:::

::::


:::

:::


## How to create variables using `mutate()`?


- Using mathematical operations `+`, `-`, `/`, `*`, `exp()`, `log()`
- Conditional creation of values `if_else(CONDITION, IF, ELSE)`
- Combine text variables (e.g. `paste(var1, var2)`)
- ...


## `filter()` variables based on their values

- `filter()` uses logical statements to create a `TRUE`/`FALSE` vector. These are used to retain or filter away observations (rows).




```{r}
#| eval: false
#| echo: true


my_true_false <- cyclingstudy$group == "INCR" 
my_true_false

```


::: {.fragment}
```{r}
#| eval: true
#| echo: false


my_true_false <- cyclingstudy$group == "INCR" 

cat(my_true_false)
```
:::

## `filter()` variables based on their values

- `filter()` uses logical statements to create a `TRUE`/`FALSE` vector. These are used to retain or filter away observations (rows).

:::: {.columns}

::: {.column width="70%"}

```{r}
#| eval: false
#| echo: true

my_true_false <- cyclingstudy$group == "INCR" 

cyclingstudy %>%
        filter(my_true_false) %>%
        select(subject, group) %>%
        print()


```
:::

::: {.column width="30%"}

::: {.fragment}
```{r}
#| eval: true
#| echo: false

my_true_false <- cyclingstudy$group == "INCR" 

cyclingstudy %>%
        filter(my_true_false) %>%
        select(subject, group) %>%
        print()

```

:::
:::
::::


## Logical statements

- To create a a vector of `TRUE` and `FALSE` for filter to work with we may use:

|Operator | Interpretation |
| --- | ---| 
| `==` | equal to |
| `!=` | not equal to |
| `>` | greater than|
| `<` | less that|
| `>=`| greater than or equal to |
| `<=` | less than or equal to |


## Logical statement in a filter

```{r}
#| eval: false
#| echo: true


cyclingstudy %>%
 filter(timepoint == "pre")        
        
cyclingstudy %>%
 filter(timepoint != "pre")

cyclingstudy %>%
 filter(VO2.max > "5000")

cyclingstudy %>%
 filter(VO2.max >= "5000")


```


## Filtering multiple variables

- To include multiple filtering steps we can use Boolean operators

|Operator | Interpretation | Example |
|---|---|---|
|`X & Y` | X and Y|`height > 175 & weight > 90`|
|`X &#124; Y` | X or Y |`height > 175 &#124; weight > 90`|
|`X & !Y` | X and not Y |`height > 175 &! weight > 90`|
|`xor(X,Y)`|X or Y, not X and Y |`xor(height > 175,  weight > 90)`|



## Filtering multiple variables

- In the `filter()` function, multiple statements separated by `,` is equivalent to using `&`


```{r}
#| eval: false
#| echo: true

# This..
cyclingstudy %>%
        filter(group == "INCR", 
               VO2.max > 5000, 
               cmj.max > 30) %>%
        print()


# is the same as
cyclingstudy %>%
        filter(group == "INCR" &
               VO2.max > 5000 & 
               cmj.max > 30) %>%
        print()






```


## Sorting a data frame using `arrange()`

- A data frame may be sorted using `arrange()`, all values and meta-data (grouping) will be preserved. 


:::: {.columns}

::: {.column width="60%"}


```{r}
#| echo: true
#| eval: false

cyclingstudy %>%
        filter(timepoint == "pre") %>%
        select(subject, age) %>%
        arrange(age)

```

:::

::: {.column width="40%"}


```{r}
#| echo: false
#| eval: true

cyclingstudy %>%
        filter(timepoint == "pre") %>%
        select(subject, age) %>%
        arrange(age)

```

:::


::::






## Sorting a data frame using `arrange()`

- To reverse to sorting from ascending to descending we use a helper function `desc()`
- The helper function also works on factor and character variables


:::: {.columns}

::: {.column width="60%"}


```{r}
#| echo: true
#| eval: false

cyclingstudy %>%
        filter(timepoint == "pre") %>%
        select(subject, age) %>%
        arrange(desc(age))

```

:::

::: {.column width="40%"}


```{r}
#| echo: false
#| eval: true

cyclingstudy %>%
        filter(timepoint == "pre") %>%
        select(subject, age) %>%
        arrange(desc(age))
```

:::


::::


## Summarising data 


- There are several ways to reduce a lot of values to a smaller set of values, sometimes these summarise can be useful!


```{r}
#| echo: false
#| fig-height: 3

set.seed(1)
dat <- data.frame(x = c(rnorm(200, 25, 4), runif(50, 25, 75), rnorm(100, 50, 4))) 


mean <- mean(dat$x)
median <- median(dat$x)

s <- sd(dat$x)

mi <- min(dat$x)
ma <- max(dat$x)

q25 <- quantile(dat$x, 0.25)
q75 <- quantile(dat$x, 0.75)


dat %>%
        ggplot(aes(x, y = 1)) + geom_jitter(shape = 21, size = 3, alpha = 0.4, fill = "orchid") + 
         scale_y_continuous(limits = c(0.1, 2)) + 
        
        annotate("segment", x = mean, xend = mean, y = 1.65, yend = 1.85, color = "darkgreen") +
        annotate("text", x = mean, label = "Mean", y = 1.95, hjust = 0, color = "darkgreen") +
        
        
        annotate("segment", x = median, xend = median, y = 1.65, yend = 1.85, color = "steelblue") +
        annotate("text", x = median, label = "Median", y = 1.95, hjust = 0, color = "steelblue") +
        
        
        annotate("segment", x = mean, xend = mean + s, y = 0.5, yend = 0.5, color = "orange") +
        annotate("text", x = mean + s + 0.1, y = 0.5, label = "Standard deviation", 
                 hjust = 0,
                 color = "orange") +
        
        annotate("segment", x = mi, xend = mi, y = 0.4, yend = 0.2, color = "red") +
        annotate("text", x = mi , y = 0.1, label = "Minimum", 
                 hjust = 0,
                 color = "red") +
        
        annotate("segment", x = ma, xend = ma, y = 0.4, yend = 0.2, color = "red") +
        annotate("text", x = ma , y = 0.1, label = "Maximum", 
                 hjust = 1,
                 color = "red") +
        
        annotate("segment", x = c(q25, q75), xend = c(q25, q75), y = 0.4, yend = 0.2, color = "purple") +
        annotate("text", x = c(q25, q75) , y = 0.1, label = c("25th quantile", "75th quantile"), 
                 hjust = c(0,1),
                 color = "purple") +
        
        
        
        theme_classic() +
        
        theme(axis.text.y = element_blank(), 
              axis.ticks.y = element_blank(), 
              axis.line.y = element_blank(), 
              axis.title.y = element_blank())

```

## Examples of summary functions in R

|Function call |Statistic |
| --- | --- |
|`mean()` | Mean |
|`median()`|Median |
|`sd()` |Standard deviation |
|`var()` |Variance |
|`min()` |Minimum|
|`max()` |Maximum|
|`quantile()`|Quantile|


## Summarise data using dplyr

- To create a summary we can use the `summarise()` function.

```{r}
# Mean age in the study
cyclingstudy %>%
        summarise(mean_age = mean(age, na.rm = TRUE), 
                  sd_age = sd(age, na.rm = TRUE))
```

- `na.rm = TRUE` tells the summary function to ignore missing values (`NA`).







